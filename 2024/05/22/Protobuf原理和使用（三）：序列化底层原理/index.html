<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Protobuf 序列化原理对于序列化，其实主要分为两个部分，编码 和 存储。  编码：首先序列化需要对数据进行编码，也就是将数据压缩，使其占用更少的字节，以便可以节省空间。 存储：然后就是对于压缩后的数据进行存储。对于每个编码后的字段，应该如何存储才能保证解码的时候可以正确的分离边界。这就是存储所需要考虑的事情。   Protobuf 的编码，结合了几种实用的编码方式，这里我会先介绍这些编码方式">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf原理和使用（三）：序列化底层原理">
<meta property="og:url" content="http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="desmoscook">
<meta property="og:description" content="Protobuf 序列化原理对于序列化，其实主要分为两个部分，编码 和 存储。  编码：首先序列化需要对数据进行编码，也就是将数据压缩，使其占用更少的字节，以便可以节省空间。 存储：然后就是对于压缩后的数据进行存储。对于每个编码后的字段，应该如何存储才能保证解码的时候可以正确的分离边界。这就是存储所需要考虑的事情。   Protobuf 的编码，结合了几种实用的编码方式，这里我会先介绍这些编码方式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/TLV%E6%8B%BC%E6%8E%A5.png">
<meta property="article:published_time" content="2024-05-22T14:41:01.000Z">
<meta property="article:modified_time" content="2024-08-04T17:47:21.179Z">
<meta property="article:author" content="desmoscook">
<meta property="article:tag" content="protobuf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/TLV%E6%8B%BC%E6%8E%A5.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Protobuf原理和使用（三）：序列化底层原理</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/05/28/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/05/15/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&text=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&is_video=false&description=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Protobuf原理和使用（三）：序列化底层原理&body=Check out this article: http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&name=Protobuf原理和使用（三）：序列化底层原理&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&t=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Protobuf 序列化原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">1. 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Varints"><span class="toc-number">2.1.</span> <span class="toc-text">1.Varints</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#varints-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">varints 变长编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varints-%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">varints 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Zigzag-%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">2. Zigzag 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81-32-64-bit"><span class="toc-number">2.3.</span> <span class="toc-text">3. 固定长度编码 32&#x2F;64-bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-string-%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.</span> <span class="toc-text">4. string 编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">Protobuf 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7-field-num"><span class="toc-number">3.1.</span> <span class="toc-text">1.字段编号(field_num)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E7%B1%BB%E5%9E%8B-wire-type"><span class="toc-number">3.2.</span> <span class="toc-text">2.传输类型(wire_type)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%AD%98%E5%82%A8-1"><span class="toc-number">4.</span> <span class="toc-text">Protobuf 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TLV-%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1. TLV 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Tag-%E5%AD%97%E6%AE%B5%E8%AE%A1%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">2. Tag 字段计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Length-%E5%AD%97%E6%AE%B5"><span class="toc-number">4.3.</span> <span class="toc-text">3. Length 字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-value-%E5%AD%97%E6%AE%B5"><span class="toc-number">4.4.</span> <span class="toc-text">4. value 字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">5.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">编码示例</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Protobuf原理和使用（三）：序列化底层原理
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">desmoscook</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-05-22T14:41:01.000Z" class="dt-published" itemprop="datePublished">2024-05-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/">protobuf原理和使用</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/protobuf/" rel="tag">protobuf</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="Protobuf-序列化原理"><a href="#Protobuf-序列化原理" class="headerlink" title="Protobuf 序列化原理"></a>Protobuf 序列化原理</h2><p>对于序列化，其实主要分为两个部分，编码 和 存储。</p>
<ol>
<li><strong>编码</strong>：首先序列化需要对数据进行编码，也就是将数据压缩，使其占用更少的字节，以便可以节省空间。</li>
<li><strong>存储</strong>：然后就是对于压缩后的数据进行存储。对于每个编码后的字段，应该如何存储才能保证解码的时候可以正确的分离边界。这就是存储所需要考虑的事情。</li>
</ol>
<p> <code>Protobuf</code> 的编码，结合了几种实用的编码方式，这里我会先介绍这些编码方式，然后解释 <code>Protobuf</code> 是如何进行存储的。</p>
<blockquote>
<p>序列化 &#x3D; 编码 + 存储</p>
</blockquote>
<h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>编码方式分为多种，如下表所示</p>
<table>
<thead>
<tr>
<th><strong>字段类型</strong></th>
<th><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
<td>Varint</td>
</tr>
<tr>
<td>fixed64, sfixed64, double</td>
<td>64-bit</td>
</tr>
<tr>
<td>string, bytes, embedded messages, packed repeated fields</td>
<td>Length-delimited</td>
</tr>
<tr>
<td>fixed32, sfixed32, float</td>
<td>32-bit</td>
</tr>
</tbody></table>
<h3 id="1-Varints"><a href="#1-Varints" class="headerlink" title="1.Varints"></a>1.Varints</h3><h4 id="varints-变长编码"><a href="#varints-变长编码" class="headerlink" title="varints 变长编码"></a>varints 变长编码</h4><p><code>Varint</code> 是一种变长编码，使用字节表示数字。值越小的数字使用的字节数也少，从而进行数据压缩</p>
<p>其中每个字节用<strong>后7位存储值</strong>。每个字节的<strong>最高位</strong>用于表示<strong>后续的字节是否属于这个数字</strong>，又称为<strong>最高有效位</strong><code>MSB</code></p>
<ul>
<li>如果最高位<code>MSB</code>位为<code>1</code>，则表示后续字节也是该数字的一部分</li>
<li>如果最高位<code>MSB</code>位为<code>0</code>，则表示该字节是数字的最后一个字节</li>
</ul>
<p>其中需要注意的是：<code>Varints</code>方法使用小端序存储（低位存储在低字节）</p>
<h4 id="varints-例子"><a href="#varints-例子" class="headerlink" title="varints 例子"></a>varints 例子</h4><p>例一：对于这个字节，<code>msb</code> 为 <code>0</code>，所以他是一个单字节，原值为 <code>1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">^ msb</span><br></pre></td></tr></table></figure>


<p>例二：对于这两个字节，第一个字节的 MSB 为 1，说明其下一个字节也用于表示当前数字。而第二个字节的 MSB 为 0，说明第二个字节是这个数字的结尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">96</span> <span class="number">01</span>              <span class="comment">// 十六进制</span></span><br><span class="line"><span class="number">10010110</span> <span class="number">00000001</span>  <span class="comment">// 转换成二进制</span></span><br><span class="line">^ msb    ^ msb</span><br></pre></td></tr></table></figure>

<p>因此，我们可以去掉 <code>msb</code> 位，将两个字节的数据进行合并。由于 <code>varints</code> 是使用小端序进行存储的，而对于我们通常的计算方法而言，是使用大端序进行计算，所以我们再把数据转换成大端序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010110</span> <span class="number">00000001</span>      <span class="comment">// 原始数据</span></span><br><span class="line"><span class="number">0010110</span> <span class="number">0000001</span>        <span class="comment">// 去掉 msb 位</span></span><br><span class="line"><span class="number">0000001</span> <span class="number">0010110</span>        <span class="comment">// 转换成大端序</span></span><br><span class="line"><span class="number">128</span> + <span class="number">16</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">150</span> <span class="comment">// 计算出结果</span></span><br></pre></td></tr></table></figure>


<h3 id="2-Zigzag-编码"><a href="#2-Zigzag-编码" class="headerlink" title="2. Zigzag 编码"></a>2. Zigzag 编码</h3><p><code>Varint</code> 编码的<strong>不足之处</strong>在于，由于每个字节少了一位用于标识（MSB位），所以对于负数，实际上会多使用一个字节。（需要额外的字节表示原本的最高位）</p>
<p><code>protobuf</code> 中有 <code>sint32</code> 和 <code>sint64</code> 来表示负数，为了更好的表示负数，<code>protobuf</code> 引入<code>Zigzag</code>编码将有符号数转换为无符号数</p>
<p><code>Zigzag</code> 编码一种变长编码方式，其<strong>使用无符号数来表示有符号数</strong>，使得绝对值小的数字都可以采用较少字节来表示，特别对表示负数的数据能更好地进行数据压缩。</p>
<p><strong>规则</strong>为，对于一个整数 <code>n</code></p>
<ul>
<li>如果是<strong>正整数</strong>，则存储其绝对值的2倍。即将 n 左移一位</li>
<li>如果为<strong>负数</strong>，则存储其绝对值的2倍减1。即将 n 左移一位，然后数据位取反</li>
</ul>
<p>因此对于序列后的数字，是偶数则为正数，是奇数则为负数。相邻奇偶两数绝对值相等</p>
<table>
<thead>
<tr>
<th>有符号整数 (<code>n</code>)</th>
<th>原二进制表示</th>
<th>ZigZag 二进制表示</th>
<th>ZigZag 编码 (<code>z</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><code>00000000</code></td>
<td><code>00000000</code></td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td><code>00000001</code></td>
<td><code>00000010</code></td>
<td>2</td>
</tr>
<tr>
<td>-1</td>
<td><code>11111111</code></td>
<td><code>00000001</code></td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td><code>00000010</code></td>
<td><code>00000100</code></td>
<td>4</td>
</tr>
<tr>
<td>-2</td>
<td><code>11111110</code></td>
<td><code>00000011</code></td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td><code>00000011</code></td>
<td><code>00000110</code></td>
<td>6</td>
</tr>
<tr>
<td>-3</td>
<td><code>11111101</code></td>
<td><code>00000101</code></td>
<td>5</td>
</tr>
</tbody></table>
<h3 id="3-固定长度编码-32-64-bit"><a href="#3-固定长度编码-32-64-bit" class="headerlink" title="3. 固定长度编码 32&#x2F;64-bit"></a>3. 固定长度编码 32&#x2F;64-bit</h3><p>固定长度编码不压缩数据，直接固定存储为 4字节 或 8字节。使用 <strong>小端序</strong> 进行存储</p>
<p>如 <code>fixed32</code> 的 <code>150</code>，转为 <code>16</code> 进制是 <code>0x96</code>，那么最终的存储则为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96 00 00 00 （0x96 0x00 0x00 0x00）</span><br></pre></td></tr></table></figure>

<p>如 <code>fixed64</code> 类型的 <code>300</code>，转为 <code>16</code> 进制是 <code>0x12C</code>，那么最终的存储则为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2C 01 00 00 00 00 00 00 （0x2C 0x01 0x00 0x00 0x00 0x00 0x00 0x00）</span><br></pre></td></tr></table></figure>

<h3 id="4-string-编码"><a href="#4-string-编码" class="headerlink" title="4. string 编码"></a>4. string 编码</h3><p><code>string</code> 的编码就是我们常见的 <code>UTF-8</code></p>
<h2 id="Protobuf-存储"><a href="#Protobuf-存储" class="headerlink" title="Protobuf 存储"></a>Protobuf 存储</h2><p><code>Protobuf</code> 消息是由一些列的键值对组成的。在消息被编码后，每个键值对都会变成一条记录，其中一条记录会通过3个部分进行编码</p>
<ul>
<li><code>Tag</code></li>
<li><code>Length</code></li>
<li><code>Value</code></li>
</ul>
<p>因此这种编码方案又称为 <code>TLV（Tag-Length-Value）</code>编码方案。</p>
<p>这几个部分是由3个重要的类型计算而成的，分别是 <code>field_num</code>，<code>wire_type</code> 和 <code>field</code></p>
<h3 id="1-字段编号-field-num"><a href="#1-字段编号-field-num" class="headerlink" title="1.字段编号(field_num)"></a>1.字段编号(field_num)</h3><p>对于编写的 <code>proto</code> 文件，对于每个字段都会有一个唯一的编号，这个就是该字段的字段编号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message LoginRequest &#123;</span><br><span class="line">    bytes name = <span class="number">1</span>;</span><br><span class="line">    bytes pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如这个 <code>message</code> 中，<code>name</code> 的字段编号就是 1，而 <code>pwd</code> 的字段编号就是 2</p>
<h3 id="2-传输类型-wire-type"><a href="#2-传输类型-wire-type" class="headerlink" title="2.传输类型(wire_type)"></a>2.传输类型(wire_type)</h3><p>每个字段都会被指定一个类型，而类型和传输类型编号同样会有对应，如下表：</p>
<ul>
<li><code>int32</code> 类型的 <code>wire_type</code> 就是 0</li>
<li>而 <code>string</code> 的 <code>wire_type</code> 就是 1</li>
</ul>
<table>
<thead>
<tr>
<th><strong>WireType</strong></th>
<th><strong>Meaning</strong></th>
<th><strong>Used For</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint</td>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited</td>
<td>string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>3</td>
<td>Start group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>4</td>
<td>End group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td>fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<p>注：<code>Start Group</code> 和 <code>End Group</code> 已经被弃用，所以后续的序列化会跳过这两个类型</p>
<h2 id="Protobuf-存储-1"><a href="#Protobuf-存储-1" class="headerlink" title="Protobuf 存储"></a>Protobuf 存储</h2><h3 id="1-TLV-格式"><a href="#1-TLV-格式" class="headerlink" title="1. TLV 格式"></a>1. TLV 格式</h3><p><code>Protobuf</code> 使用 <code>T-L-V</code> 的编码格式进行存储，即 <code>Tag-Length-Value</code> （其中 <code>Length</code> 是可选参数）</p>
<p><code>Protobuf</code> 的每个字段 <code>field</code> 都使用 <code>TLV</code> 进行序列化，即每个 <code>field</code> 对应一个 <code>TLV</code>。然后 <code>Protobuf</code> 会将所有的 <code>field</code> 进行拼接，得到最终的序列。</p>
<p>因此， <code>Message</code>由一个个字段 <code>field</code> 组成， 每个字段由 TLV 进行组成，所以一个 <code>Message</code> 就可以看成是多个字段的 <code>TLV</code> 序列拼接成的一个二进制字节流。</p>
<p><img src="/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/TLV%E6%8B%BC%E6%8E%A5.png"> </p>
<p><code>T-L-V</code> 存储方式的 <strong>优点</strong> 在于</p>
<ol>
<li>由于有 <code>Length</code> 属性的存在，因此 <code>TLV</code> <strong>不需要分隔符就能分隔字段</strong>，节省了分隔符的空间，所以序列化的空闲效率非常高</li>
<li>如果某个字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不需要编码，相应字段在解码时才会被设置为默认值。</li>
</ol>
<blockquote>
<p>对于 <code>Varint</code> &amp; <code>Zigzag</code> 编码，由于编码自身可以进行边界分割，所以省略了<code>T-L-V</code>中的字节长度 <code>Length</code>，进一步的提高了序列化效率</p>
</blockquote>
<h3 id="2-Tag-字段计算"><a href="#2-Tag-字段计算" class="headerlink" title="2. Tag 字段计算"></a>2. Tag 字段计算</h3><p><code>Tag</code> 在作用是标识字段，其中存储了字段的 <strong>标识号（field_number）</strong> 和 <strong>数据类型（wire_type）</strong>，使用 <code>varints</code> 编码方式进行编码</p>
<p>其计算方法是 <code>field_num &lt;&lt; 3 | wire_type</code> (也称为每个<code>filed</code>的<code>key</code>或者键)。因此 低3位永远用来表示 <code>wire_type</code></p>
<p>那么我们现在来计算一个完整的序列化后的字段的 Tag</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08</span> <span class="number">96</span> <span class="number">01</span>  <span class="comment">// 原始值</span></span><br><span class="line"><span class="number">00001000</span> <span class="number">10010110</span> <span class="number">00000001</span>  <span class="comment">// 转换成二进制</span></span><br></pre></td></tr></table></figure>

<p>由于第一个字符一定是 <code>varints</code> 编码的 <code>Tag</code>，而 <code>Tag</code> 的 <code>msb</code> 位是 0。所以 <code>Tag</code> 只占用一个字节</p>
<p>且 <code>Tag = 000 1000</code>，那么我们可以根据 后三位得到 <code>wire_type = 0</code>，然后将 <code>Tag</code> 右移3位得到 <code>0001</code>，即 <code>field_num = 1</code></p>
<h3 id="3-Length-字段"><a href="#3-Length-字段" class="headerlink" title="3. Length 字段"></a>3. Length 字段</h3><p><code>Length</code> 标识 <code>Value</code> 的长度，和 <code>Tag</code> 一样，也使用 <code>varints</code> 编码方式进行编码</p>
<p><code>TLV</code> 中的 <code>length</code> 是一个可选参数，<code>length</code> 是否需要主要根据 <code>wire_type</code> 来决定。</p>
<p>具体存储结构如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>wire_type</strong></th>
<th><strong>含义</strong></th>
<th><strong>二进制存储结构</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint</td>
<td>Tag-Value</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>Tag-Value</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited</td>
<td>Tag-Length-Value</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td>Tag-Value</td>
</tr>
</tbody></table>
<h3 id="4-value-字段"><a href="#4-value-字段" class="headerlink" title="4. value 字段"></a>4. value 字段</h3><p><code>value</code> 字段可以直接根据 <code>value</code> 的类型对应的编码获得</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>回顾一下，<code>Protobuf</code> 的编码分为字段和消息两部分，每个字段包括：</p>
<ol>
<li><strong>Field Number（字段号）</strong>：标识字段的唯一标识符。</li>
<li><strong>Wire Type（传输类型）</strong>：描述字段值的编码类型。</li>
<li><strong>Field Value（字段值）</strong>：字段的实际值。</li>
</ol>
<h4 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h4><p>以下是一个简单的 <code>Protobuf</code> 消息定义示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">    int32 id = <span class="number">1</span>;</span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> is_student = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设消息的值如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">123</span></span><br><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">is_student = <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p>对于上面的 <code>Person</code> 消息，编码过程如下：</p>
<p><code>id</code> 相关信息</p>
<ul>
<li><code>Field Number</code>: 1</li>
<li><code>Wire Type</code>: 0（Varint，用于整数）</li>
<li><code>Field Value</code>: 123（假设 id 的值为 123）<br>计算可得</li>
<li><code>Tag</code>：<code>(1 &lt;&lt; 3) | 0 = 8</code>，即 <code>Varint</code> 编码为 <code>0x08</code></li>
<li><code>Value</code>： <code>7b</code>（123 的 Varint 编码）</li>
</ul>
<p><code>name</code> 相关信息</p>
<ul>
<li><code>Field Number</code>: 2</li>
<li><code>Wire Type</code>: 2（Length-delimited，用于字符串）</li>
<li><code>Field Value</code>: “Alice”（假设 name 的值为 “Alice”）、<br>计算可得</li>
<li><code>Tag</code> ： <code>(2 &lt;&lt; 3) | 2 = 18</code>，<code>Varint</code> 编码为 <code>0x12</code></li>
<li><code>Length</code>：<code>0x05</code>（字符串长度为5）</li>
<li><code>Value</code>: <code>Alice</code> 的 ASCII 编码为 <code>0x41 0x6C 0x69 0x63 0x65</code></li>
</ul>
<p><code>is_student</code> 相关信息</p>
<ul>
<li><code>Field Number</code>: 3</li>
<li><code>Wire Type</code>: 0（Varint，用于布尔值）</li>
<li><code>Field Value</code>: true（假设 is_student 的值为 true）<br> 计算可得</li>
<li><code>Tag</code>：<code>(3 &lt;&lt; 3) | 0 = 24</code>，<code>Varint</code> 编码为 <code>0x18</code></li>
<li><code>Value</code>：<code>0x01</code></li>
</ul>
<p>将所有字段的<code>TLV</code>编码结果拼接在一起，得到最终的序列化输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 7b 12 05 41 6c 69 63 65 18 01</span><br></pre></td></tr></table></figure>



<p>参考文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://protobuf.dev/programming-guides/encoding/">https://protobuf.dev/programming-guides/encoding/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/70568606">https://blog.csdn.net/carson_ho/article/details/70568606</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Protobuf 序列化原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">1. 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Varints"><span class="toc-number">2.1.</span> <span class="toc-text">1.Varints</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#varints-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">varints 变长编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varints-%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">varints 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Zigzag-%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">2. Zigzag 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81-32-64-bit"><span class="toc-number">2.3.</span> <span class="toc-text">3. 固定长度编码 32&#x2F;64-bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-string-%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.</span> <span class="toc-text">4. string 编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">Protobuf 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7-field-num"><span class="toc-number">3.1.</span> <span class="toc-text">1.字段编号(field_num)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E7%B1%BB%E5%9E%8B-wire-type"><span class="toc-number">3.2.</span> <span class="toc-text">2.传输类型(wire_type)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf-%E5%AD%98%E5%82%A8-1"><span class="toc-number">4.</span> <span class="toc-text">Protobuf 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TLV-%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1. TLV 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Tag-%E5%AD%97%E6%AE%B5%E8%AE%A1%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">2. Tag 字段计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Length-%E5%AD%97%E6%AE%B5"><span class="toc-number">4.3.</span> <span class="toc-text">3. Length 字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-value-%E5%AD%97%E6%AE%B5"><span class="toc-number">4.4.</span> <span class="toc-text">4. value 字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">5.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">编码示例</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&text=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&is_video=false&description=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Protobuf原理和使用（三）：序列化底层原理&body=Check out this article: http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&title=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&name=Protobuf原理和使用（三）：序列化底层原理&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://desmoscook.github.io/2024/05/22/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/&t=Protobuf原理和使用（三）：序列化底层原理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    desmoscook
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
