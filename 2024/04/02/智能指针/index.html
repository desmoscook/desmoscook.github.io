<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="1.智能指针的作用在现代C++编程中，智能指针扮演着不可或缺的角色。但是既然由传统的指针的存在了，为什么还需要智能指针呢？ 对于传统的智能指针而言，需要程序员手动的进行管理内存。而即使再聪明的人也会有犯错的时候，即使再老练的程序员也会有忘记delete的时候。为了进行自动化的内存管理，防止内存泄露的频繁出现，智能指针应运而生。 智能指针是一种封装了原始指针的智能对象，其核心思想就是将管理内存进行自">
<meta property="og:type" content="article">
<meta property="og:title" content="智能指针底层原理详解">
<meta property="og:url" content="http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/index.html">
<meta property="og:site_name" content="desmoscook">
<meta property="og:description" content="1.智能指针的作用在现代C++编程中，智能指针扮演着不可或缺的角色。但是既然由传统的指针的存在了，为什么还需要智能指针呢？ 对于传统的智能指针而言，需要程序员手动的进行管理内存。而即使再聪明的人也会有犯错的时候，即使再老练的程序员也会有忘记delete的时候。为了进行自动化的内存管理，防止内存泄露的频繁出现，智能指针应运而生。 智能指针是一种封装了原始指针的智能对象，其核心思想就是将管理内存进行自">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-02T15:05:24.000Z">
<meta property="article:modified_time" content="2024-07-29T18:50:48.861Z">
<meta property="article:author" content="desmoscook">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>智能指针底层原理详解</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/05/08/Protobuf%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BB%8B%E7%BB%8D/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/20/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFO(n)%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&text=智能指针底层原理详解"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&is_video=false&description=智能指针底层原理详解"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=智能指针底层原理详解&body=Check out this article: http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&name=智能指针底层原理详解&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&t=智能指针底层原理详解"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">1.智能指针的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2.智能指针的分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.智能指针的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1内存管理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%92%8C%E5%BB%B6%E8%BF%9F%E9%94%80%E6%AF%81"><span class="toc-number">3.2.</span> <span class="toc-text">3.2引用计数和延迟销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.智能指针的不合理使用会出现什么问题？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.什么时候才应该使用智能指针？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%80%A7%E8%83%BD%E6%95%8F%E6%84%9F%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">3.2 性能敏感区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">引用计数的性能开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%94%80%E6%AF%81%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">延迟销毁的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%80%83%E9%87%8F"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">适用场景的考量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%BB%86%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">5.0.1.4.</span> <span class="toc-text">精细的资源管理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%BA%A6%E6%9D%9F%E7%9A%84%E8%80%83%E9%87%8F"><span class="toc-number">5.0.1.5.</span> <span class="toc-text">资源约束的考量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%80%A7%E8%A6%81%E6%B1%82"><span class="toc-number">5.0.1.6.</span> <span class="toc-text">实时性要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%BB%86%E6%8E%A7%E5%88%B6%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">5.0.1.7.</span> <span class="toc-text">精细控制的需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">5.0.1.8.</span> <span class="toc-text">替代方案</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%BB%A5%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">第四章: 智能指针滥用的具体案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.0.1.</span> <span class="toc-text">4.1 循环引用与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">4.1.1 问题示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">4.1.2 解决策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E9%87%8D%E8%A6%81%E6%8F%90%E7%A4%BA"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">4.1.3 重要提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%94%99%E8%AF%AF%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.2.</span> <span class="toc-text">4.2 错误的智能指针转换与类型安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.2.0.1.</span> <span class="toc-text">4.2.1 错误示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E9%81%BF%E5%85%8D%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.2.0.2.</span> <span class="toc-text">4.2.3 避免类型安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%87%E5%BA%A6%E5%B0%81%E8%A3%85%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%BB%A5%E7%94%A8"><span class="toc-number">6.0.3.</span> <span class="toc-text">4.3 过度封装与接口滥用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">6.0.3.0.1.</span> <span class="toc-text">4.3.1 问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.0.3.0.2.</span> <span class="toc-text">4.3.2 正确的设计原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="toc-number">6.0.3.0.3.</span> <span class="toc-text">4.3.3 实践中的平衡</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-number">7.</span> <span class="toc-text">第五章: 正确使用智能指针的高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%8B%E5%8A%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">5.1 手动资源管理与智能指针的结合使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E7%90%86%E8%A7%A3%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">5.1.1 理解资源管理的复杂性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">5.1.2 结合使用的策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">5.1.3 自定义删除器的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-%E7%BB%93%E5%90%88%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">5.1.4 结合手动管理与智能指针的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">7.0.2.</span> <span class="toc-text">5.2 使用自定义删除器优化资源回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">5.2.1 自定义删除器的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">5.2.2 实现自定义删除器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">5.2.3 自定义删除器的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%92%E5%8A%A8"><span class="toc-number">7.0.2.4.</span> <span class="toc-text">5.2.4 自定义删除器与智能指针的互动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">7.0.2.5.</span> <span class="toc-text">5.2.5 优化资源回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E7%8E%B0%E4%BB%A3C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.3.</span> <span class="toc-text">5.3 智能指针与现代C++设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.1.</span> <span class="toc-text">5.3.1 工厂模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.2.</span> <span class="toc-text">5.3.2 观察者模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.3.</span> <span class="toc-text">5.3.3 单例模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.0.3.4.</span> <span class="toc-text">5.3.4 使用智能指针的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E8%AF%AD"><span class="toc-number">7.1.</span> <span class="toc-text">第六章: 结语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%87%8D%E7%94%B3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.1.</span> <span class="toc-text">6.1 重申智能指针使用的原则</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        智能指针底层原理详解
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">desmoscook</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-02T15:05:24.000Z" class="dt-published" itemprop="datePublished">2024-04-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C/" rel="tag">C++</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="1-智能指针的作用"><a href="#1-智能指针的作用" class="headerlink" title="1.智能指针的作用"></a>1.智能指针的作用</h1><p>在现代C++编程中，智能指针扮演着不可或缺的角色。但是既然由传统的指针的存在了，为什么还需要智能指针呢？</p>
<p>对于传统的智能指针而言，需要程序员手动的进行管理内存。而即使再聪明的人也会有犯错的时候，即使再老练的程序员也会有忘记<code>delete</code>的时候。为了进行自动化的内存管理，防止内存泄露的频繁出现，智能指针应运而生。</p>
<p>智能指针是一种封装了原始指针的智能对象，其核心思想就是将管理内存进行自动化，以防止内存泄漏的出现。智能指针通过<code>RAII</code>机制进行内存的自动化管理。RAII机制即<code>Resource Acquisition Is Initialization</code>，通过将资源的获取和释放与对象的生命周期进行绑定，来实现资源管理自动化。</p>
<p><code>RAII</code>机制是通过类的构造函数和析构函数实现的，其中构造函数负责分配内存，而析构函数则确保在对象生命周期结束时释放内存。</p>
<p>正如计算机科学家 Edsger Dijkstra 所指出的，“简化复杂性是计算机编程的本质。”智能指针的设计哲学正是基于这样的理念：通过简化内存管理的复杂性，使程序员能够专注于业务逻辑的实现，而不是被底层的资源管理细节所困扰。智能指针的使用不仅减少了代码的冗余，提高了代码的可读性和可维护性，而且通过自动管理内存的生命周期，大大降低了内存泄露的风险。</p>
<h1 id="2-智能指针的分类"><a href="#2-智能指针的分类" class="headerlink" title="2.智能指针的分类"></a>2.智能指针的分类</h1><p>智能指针主要分为3种，不同的智能指针是为了解决不同的实际问题</p>
<ul>
<li><code>shared_ptr</code></li>
<li><code>unique_ptr</code></li>
<li><code>weak_ptr</code></li>
</ul>
<p>shared_ptr主要是为了解决多个指针需要共享资源的情况</p>
<h1 id="3-智能指针的工作原理"><a href="#3-智能指针的工作原理" class="headerlink" title="3.智能指针的工作原理"></a>3.智能指针的工作原理</h1><h2 id="3-1内存管理机制"><a href="#3-1内存管理机制" class="headerlink" title="3.1内存管理机制"></a>3.1内存管理机制</h2><h2 id="3-2引用计数和延迟销毁"><a href="#3-2引用计数和延迟销毁" class="headerlink" title="3.2引用计数和延迟销毁"></a>3.2引用计数和延迟销毁</h2><h1 id="4-智能指针的不合理使用会出现什么问题？"><a href="#4-智能指针的不合理使用会出现什么问题？" class="headerlink" title="4.智能指针的不合理使用会出现什么问题？"></a>4.智能指针的不合理使用会出现什么问题？</h1><h1 id="5-什么时候才应该使用智能指针？"><a href="#5-什么时候才应该使用智能指针？" class="headerlink" title="5.什么时候才应该使用智能指针？"></a>5.什么时候才应该使用智能指针？</h1><p>指针智能既然有这么多优点，是不是任何场合都应该使用智能指针？</p>
<p>然而，智能指针虽然提供了很多的便利，但它并不是万能药。过度的使用智能指针会导致更严重的问题的出现。</p>
<p>智能指针是对于传统指针的封装，因此其</p>
<p>在探索智能指针的角色与目的时，我们不仅仅是在讨论一种技术或工具的使用，实际上，我们是在关注如何更加人性化地与机器沟通。我们的目标是实现一种和谐的状态，即人类的智慧与机器的效率能够相得益彰。这种追求不仅反映了对技术的深入理解，也体现了对人类自身能力和局限的深刻洞察。</p>
<h3 id="3-2-性能敏感区域"><a href="#3-2-性能敏感区域" class="headerlink" title="3.2 性能敏感区域"></a>3.2 性能敏感区域</h3><p>在性能敏感的应用中，每一次内存分配和释放、每一次CPU周期的使用都至关重要。这些场合往往要求开发者精细控制资源的管理，以确保最高效率的执行。智能指针虽然提供了便利的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?spm=a2c6h.13046898.publish-article.62.65146ffazdgg0B&q=%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">自动内存管理</a>，但这种便利性并非没有代价。特别是在性能关键的代码路径中，智能指针的开销可能成为性能瓶颈。</p>
<h4 id="引用计数的性能开销"><a href="#引用计数的性能开销" class="headerlink" title="引用计数的性能开销"></a>引用计数的性能开销</h4><p><code>std::shared_ptr</code>通过引用计数机制来实现资源的共享所有权。虽然这为资源管理提供了极大的灵活性，但引用计数的更新是需要成本的，尤其是在多线程环境下。对<code>std::shared_ptr</code>的复制和销毁涉及对引用计数的增加和减少，这些操作需要是原子的，以防止数据竞争。原子操作相比于普通操作来说更加昂贵，它们可能导致CPU缓存行的争夺，降低程序的整体性能。</p>
<h4 id="延迟销毁的影响"><a href="#延迟销毁的影响" class="headerlink" title="延迟销毁的影响"></a>延迟销毁的影响</h4><p>智能指针确保了资源的自动释放，但这种自动化带来的是延迟销毁的行为。在资源不再需要时，它们不会立即被回收，而是要等到智能指针对象的生命周期结束。在紧密循环或高频调用的场景中，这可能导致内存使用的峰值比预期的要高，影响到系统的性能表现。</p>
<h4 id="适用场景的考量"><a href="#适用场景的考量" class="headerlink" title="适用场景的考量"></a>适用场景的考量</h4><p>因此，在性能敏感的区域，直接使用原始指针或其他轻量级的资源管理技术可能是更合适的选择。例如，在游戏开发、高频交易系统或实时处理应用中，开发者可能会优先选择那些能提供更精细控制的技术。这并不是说在这些场合完全不能使用智能指针，而是在使用前需要仔细评估其带来的性能影响。</p>
<h4 id="精细的资源管理策略"><a href="#精细的资源管理策略" class="headerlink" title="精细的资源管理策略"></a>精细的资源管理策略</h4><p>在需要使用智能指针的场景中，可以通过一些策略来减轻性能开销，如在可能的情况下使用<code>std::unique_ptr</code>代替<code>std::shared_ptr</code>，因为<code>std::unique_ptr</code>几乎不引入额外开销。另外，通过避免不必要的智能指针复制操作，减少引用计数的更新，也能够降低性能损耗。</p>
<p>智能指针的正确使用，要求开发者不仅了解其内部机制和潜在的性能影响，还需要根据应用的具体需求做出合理的选择。正如在架构设计中平衡美观与功能性一样，软件开发中资源管理的选择也需要在便利性与性能之间找到平衡点。通过在性能敏感区域谨慎使用智能指针，我们可以确保既不牺牲代码的安全性和可维护性，又能满足应用对性能的严格要求。</p>
<h4 id="资源约束的考量"><a href="#资源约束的考量" class="headerlink" title="资源约束的考量"></a>资源约束的考量</h4><p>嵌入式系统通常具有有限的内存和计算资源。在这种约束条件下，每一个字节的内存都是宝贵的，CPU的每一次计算都需要精打细算。智能指针，尤其是<code>std::shared_ptr</code>由于其引用计数机制，会引入额外的内存和性能开销，这在资源受限的环境中可能是不可接受的。</p>
<h4 id="实时性要求"><a href="#实时性要求" class="headerlink" title="实时性要求"></a>实时性要求</h4><p>许多嵌入式应用，如汽车电子、航空电子和工业控制系统，对实时性有着严格的要求。这意味着系统必须在规定的时间内响应事件，任何延迟都可能导致严重后果。智能指针的自动内存管理虽然方便，但可能导致不可预测的延迟，特别是当涉及到内存释放时。在这些场合，直接管理内存，尽管更加复杂和风险较高，却能提供更可控的性能表现。</p>
<h4 id="精细控制的需求"><a href="#精细控制的需求" class="headerlink" title="精细控制的需求"></a>精细控制的需求</h4><p>系统底层开发和嵌入式编程往往需要对内存布局和程序行为有精确的控制，以满足特定的技术和业务需求。智能指针隐藏了许多底层细节，这种抽象虽然对于应用层开发是有益的，但在需要精细操作硬件的场景中，可能会变成一个障碍。</p>
<h4 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h4><p>在这些领域，开发者可能更倾向于使用原始指针和自定义的内存管理策略，或者采用特定于项目的轻量级智能指针实现，这些实现能够提供必要的自动化管理，同时最小化资源消耗和性能开销。例如，开发者可以设计一个简单的引用计数系统，或者使用池分配器来管理特定类型对象的生命周期，这样既保持了控制的灵活性，又能在一定程度上减少内存管理的错误。</p>
<p>智能指针是现代C++中极为强大的工具，它们在许多应用程序开发场景中提供了巨大的便利和安全性。然而，在系统底层开发和嵌入式编程这样的特殊领域，直接和精细的资源控制往往比自动化管理更为重要。在这些场景下，了解何时以及如何回归到更基础的内存管理技术，是每位开发者都需要掌握的重要技能。正如在艺术创作中选择合适的画笔和颜料一样，合理选择和使用工具，是实现技术杰作的基础。通过在合适的环境中恰当使用智能指针或其他内存管理手段，开发者可以构建出既高效又稳定的系统，满足最严格的技术要求。</p>
<h1 id="第四章-智能指针滥用的具体案例"><a href="#第四章-智能指针滥用的具体案例" class="headerlink" title="第四章: 智能指针滥用的具体案例"></a>第四章: 智能指针滥用的具体案例</h1><h3 id="4-1-循环引用与内存泄漏"><a href="#4-1-循环引用与内存泄漏" class="headerlink" title="4.1 循环引用与内存泄漏"></a>4.1 循环引用与内存泄漏</h3><p>在深入讨论智能指针滥用的具体案例之前，了解循环引用的概念及其如何导致内存泄漏是至关重要的。循环引用发生在两个或更多的对象通过智能指针相互引用时，造成的问题是，即使它们不再被程序的其他部分所需要，它们也不会被自动销毁。这种情况下，智能指针的引用计数机制无法降到零，因此，相关资源不会被释放，从而导致内存泄漏。</p>
<h4 id="4-1-1-问题示例"><a href="#4-1-1-问题示例" class="headerlink" title="4.1.1 问题示例"></a>4.1.1 问题示例</h4><p>考虑以下两个类，<code>ClassA</code> 和 <code>ClassB</code>，它们通过 <code>std::shared_ptr</code> 相互引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; b_ptr;    ~<span class="built_in">ClassA</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ClassA 被销毁&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; a_ptr;    ~<span class="built_in">ClassB</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ClassB 被销毁&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>ClassA</code> 的实例和 <code>ClassB</code> 的实例通过 <code>shared_ptr</code> 相互持有引用，那么即便外部对这些实例的引用被释放，它们的引用计数也不会降到零。因此，它们的析构函数不会被调用，导致内存泄漏。</p>
<h4 id="4-1-2-解决策略"><a href="#4-1-2-解决策略" class="headerlink" title="4.1.2 解决策略"></a>4.1.2 解决策略</h4><p>解决循环引用问题的一种方法是使用 <code>std::weak_ptr</code>。<code>weak_ptr</code> 是一种智能指针，它不会增加对象的引用计数，这意味着它可以安全地引用由 <code>shared_ptr</code> 管理的对象，而不会阻止对象被销毁。</p>
<p>修改上述例子，可以将其中一个类对另一个类的引用改为 <code>std::weak_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;ClassB&gt; b_ptr; <span class="comment">// 修改为 weak_ptr    ~ClassA() &#123; std::cout &lt;&lt; &quot;ClassA 被销毁&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，即使 <code>ClassA</code> 和 <code>ClassB</code> 相互引用，<code>ClassA</code> 对 <code>ClassB</code> 的引用不会阻止 <code>ClassB</code> 的销毁，反之亦然。当外部对这些对象的 <code>shared_ptr</code> 被销毁时，相关对象的引用计数会降到零，从而触发析构过程，有效避免内存泄漏。</p>
<h4 id="4-1-3-重要提示"><a href="#4-1-3-重要提示" class="headerlink" title="4.1.3 重要提示"></a>4.1.3 重要提示</h4><p>在使用 <code>std::weak_ptr</code> 解决循环引用问题时，开发者必须注意，尝试访问 <code>weak_ptr</code> 指向的对象前，应先将其转换为 <code>std::shared_ptr</code>。这一步骤是必要的，因为 <code>weak_ptr</code> 本身不保证对象的存在，只有通过转换，我们才能确保访问时对象仍然有效。</p>
<p>循环引用和内存泄漏是智能指针使用中常见的陷阱之一。</p>
<h3 id="4-2-错误的智能指针转换与类型安全问题"><a href="#4-2-错误的智能指针转换与类型安全问题" class="headerlink" title="4.2 错误的智能指针转换与类型安全问题"></a>4.2 错误的智能指针转换与类型安全问题</h3><p>智能指针的另一个常见滥用场景是错误地进行智能指针之间的转换，特别是在处理继承关系时。这不仅可能导致运行时错误，也可能引入类型安全问题。理解智能指针转换的正确方法和潜在的风险对于避免这些问题至关重要。</p>
<h5 id="4-2-1-错误示例"><a href="#4-2-1-错误示例" class="headerlink" title="4.2.1 错误示例"></a>4.2.1 错误示例</h5><p>假设有基类 <code>Base</code> 和派生类 <code>Derived</code>，并且开发者希望通过基类的智能指针来操作派生类的对象。错误的转换方法可能导致未定义行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Base&gt; basePtr = std::<span class="built_in">make_shared</span>&lt;Derived&gt;();</span><br><span class="line"><span class="comment">// 错误的转换尝试</span></span><br><span class="line">std::shared_ptr&lt;Derived&gt; derivedPtr = std::<span class="built_in">static_pointer_cast</span>&lt;Derived&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">虽然上述代码在某些情况下看似工作正常，但如果 `basePtr` 实际上并不指向一个 `Derived` 类型的对象，这种转换就会引入运行时错误。</span><br><span class="line"></span><br><span class="line">##### <span class="number">4.2</span><span class="number">.2</span> 正确的转换方法</span><br><span class="line"></span><br><span class="line">正确处理智能指针之间的转换包括使用 `std::dynamic_pointer_cast`。与 `std::static_pointer_cast` 相比，`std::dynamic_pointer_cast` 在转换失败时会返回空指针，从而提供了一种类型安全的转换机制：</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Base&gt; basePtr = std::<span class="built_in">make_shared</span>&lt;Derived&gt;();</span><br><span class="line"><span class="comment">// 正确的转换方法</span></span><br><span class="line">std::shared_ptr&lt;Derived&gt; derivedPtr = std::<span class="built_in">dynamic_pointer_cast</span>&lt;Derived&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>std::dynamic_pointer_cast</code>，当转换不合法时，程序能够安全地处理失败情况，而不是导致未定义行为。</p>
<h5 id="4-2-3-避免类型安全问题"><a href="#4-2-3-避免类型安全问题" class="headerlink" title="4.2.3 避免类型安全问题"></a>4.2.3 避免类型安全问题</h5><p>为了进一步保障类型安全，开发者应避免不必要的智能指针转换，尤其是在不完全确定对象类型的情况下。通过设计清晰的类层次结构和接口，可以减少对于类型转换的需求。同时，利用多态和虚函数可以在不显式转换指针类型的情况下实现相同的功能，从而避免潜在的类型安全问题。</p>
<p>智能指针提供了方便的资源管理机制，但它们的不当使用可能会导致一系列问题，包括类型安全风险。理解和遵循正确的智能指针转换准则是确保C++程序安全和高效的关键。通过避免不必要或错误的转换，开发者可以降低引入错误的风险，从而提升程序的稳定性和可维护性。</p>
<h3 id="4-3-过度封装与接口滥用"><a href="#4-3-过度封装与接口滥用" class="headerlink" title="4.3 过度封装与接口滥用"></a>4.3 过度封装与接口滥用</h3><p>智能指针的过度封装和接口滥用是C++开发中另一个常见的问题。这种做法可能导致代码的可读性和可维护性下降，同时增加了错误发生的概率。在设计类和接口时，应当谨慎使用智能指针，确保它们的使用是出于管理资源生命周期的必要，而不是无谓地增加复杂度。</p>
<h5 id="4-3-1-问题描述"><a href="#4-3-1-问题描述" class="headerlink" title="4.3.1 问题描述"></a>4.3.1 问题描述</h5><p>在某些情况下，开发者可能会不恰当地将智能指针作为函数参数或返回值，即使这样做并不提供任何实际的好处。例如，一个函数可以直接返回对象实例而不是智能指针，如果该对象的生命周期很简单，或者使用值语义更为合适。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Object&gt; <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数无需返回一个智能指针，特别是当<code>Object</code>可以轻松地通过值返回，而不会导致性能问题时。这种情况下，过度使用智能指针只会增加不必要的引用计数操作，从而降低性能。</p>
<h5 id="4-3-2-正确的设计原则"><a href="#4-3-2-正确的设计原则" class="headerlink" title="4.3.2 正确的设计原则"></a>4.3.2 正确的设计原则</h5><p>正确的设计应该侧重于使用最简单的适合任务的工具。如果对象的生命周期由函数或作用域自然管理，则优先考虑使用栈分配或值返回。只有在需要共享所有权或对象生命周期需要跨越多个上下文管理时，才应考虑使用<code>std::shared_ptr</code>。</p>
<p>当确实需要使用智能指针时，应考虑函数或类接口的设计，使其尽可能简洁明了。例如，如果一个类需要保持对另一个类的引用，而这个引用不会改变对象的所有权，那么<code>std::unique_ptr</code>或<code>std::weak_ptr</code>可能是更好的选择，而不是默认使用<code>std::shared_ptr</code>。</p>
<h5 id="4-3-3-实践中的平衡"><a href="#4-3-3-实践中的平衡" class="headerlink" title="4.3.3 实践中的平衡"></a>4.3.3 实践中的平衡</h5><p>理解何时以及如何使用智能指针是提高C++代码质量的关键。避免过度封装和接口滥用，可以使代码更加清晰、高效，并减少错误。在设计接口和实现功能时，应当仔细考虑是否真的需要智能指针，以及选择哪种类型的智能指针最合适。</p>
<p>总之，智能指针是现代C++中管理资源和内存的有力工具，但它们也需要谨慎使用。通过避免循环引用、正确进行类型转换，以及避免不必要的封装和滥用，开发者可以充分利用智能指针的优势，同时避免它们的陷阱。在软件设计和实现中保持这种平衡，是每个C++开发者追求的目标。</p>
<h1 id="第五章-正确使用智能指针的高级技巧"><a href="#第五章-正确使用智能指针的高级技巧" class="headerlink" title="第五章: 正确使用智能指针的高级技巧"></a>第五章: 正确使用智能指针的高级技巧</h1><h3 id="5-1-手动资源管理与智能指针的结合使用"><a href="#5-1-手动资源管理与智能指针的结合使用" class="headerlink" title="5.1 手动资源管理与智能指针的结合使用"></a>5.1 手动资源管理与智能指针的结合使用</h3><p>在C++编程实践中，智能指针是管理动态分配内存资源的首选工具，因为它们可以自动释放所占用的内存，从而避免内存泄漏等问题。然而，在某些特定情况下，单纯依赖智能指针可能不足以处理所有资源管理的需求，尤其是当涉及到非内存资源或需要与旧代码库互操作时。这时，将手动资源管理与智能指针相结合使用，就成为了一种高级且有效的策略。</p>
<h4 id="5-1-1-理解资源管理的复杂性"><a href="#5-1-1-理解资源管理的复杂性" class="headerlink" title="5.1.1 理解资源管理的复杂性"></a>5.1.1 理解资源管理的复杂性</h4><p>资源管理不仅仅关乎内存。在现代C++应用程序中，资源可以指文件句柄、网络连接、数据库连接或任何需要在使用完毕后正确释放的资源。智能指针主要解决内存管理问题，但对于其他类型的资源，我们可能需要采用不同的策略。</p>
<h4 id="5-1-2-结合使用的策略"><a href="#5-1-2-结合使用的策略" class="headerlink" title="5.1.2 结合使用的策略"></a>5.1.2 结合使用的策略</h4><p>一种有效的策略是使用智能指针来管理动态分配的内存，同时利用RAII（资源获取即初始化）模式管理其他类型的资源。例如，我们可以使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>与自定义删除器一起工作，以确保在资源不再需要时，不仅内存得到释放，同时也能调用适当的清理函数来释放非内存资源。</p>
<h4 id="5-1-3-自定义删除器的使用"><a href="#5-1-3-自定义删除器的使用" class="headerlink" title="5.1.3 自定义删除器的使用"></a>5.1.3 自定义删除器的使用</h4><p>自定义删除器是智能指针非常强大的一个特性，它允许我们指定一个函数或函数对象，在智能指针析构时自动调用，从而执行资源的清理工作。这使得智能指针不仅限于内存管理，也可以用于管理文件句柄、数据库连接等。</p>
<p>例如，如果我们使用<code>std::unique_ptr</code>管理一个打开的文件，可以提供一个自定义删除器，以确保文件在不再需要时自动关闭：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closeFile</span><span class="params">(std::FILE* fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;        std::<span class="built_in">fclose</span>(fp);    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;std::FILE, <span class="title">decltype</span><span class="params">(&amp;closeFile)</span>&gt; <span class="title">filePtr</span><span class="params">(std::fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), &amp;closeFile)</span></span>;    </span><br><span class="line">    <span class="comment">// 使用filePtr进行文件操作    return 0; // 当filePtr离开作用域时，closeFile会被自动调用来关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-1-4-结合手动管理与智能指针的优势"><a href="#5-1-4-结合手动管理与智能指针的优势" class="headerlink" title="5.1.4 结合手动管理与智能指针的优势"></a>5.1.4 结合手动管理与智能指针的优势</h4><p>通过结合手动资源管理与智能指针，我们可以在保持代码安全性的同时，获得更大的灵活性和控制力。这种方法特别适合于需要精细控制资源生命周期，或需要与遗留代码库或第三方库互操作的场景。</p>
<p>结合使用手动管理和智能指针，让我们可以在C++中实现更为复杂和高效的资源管理模式，确保资源使用的安全性和高效性，同时也使代码更加的清晰和易于维护。</p>
<h3 id="5-2-使用自定义删除器优化资源回收"><a href="#5-2-使用自定义删除器优化资源回收" class="headerlink" title="5.2 使用自定义删除器优化资源回收"></a>5.2 使用自定义删除器优化资源回收</h3><p>在C++中，智能指针的自定义删除器功能不仅仅允许我们扩展智能指针的用途，从而覆盖更广泛的资源管理场景，而且还提供了一种优化资源回收过程的手段。通过为智能指针指定一个自定义删除器，开发者可以确保即使在复杂的应用程序中，资源的释放也能够按照预期进行，从而避免资源泄露等问题。</p>
<h4 id="5-2-1-自定义删除器的概念"><a href="#5-2-1-自定义删除器的概念" class="headerlink" title="5.2.1 自定义删除器的概念"></a>5.2.1 自定义删除器的概念</h4><p>自定义删除器是一种与智能指针结合使用的函数或可调用对象，用于在智能指针对象销毁时执行特定的资源清理操作。这种机制让智能指针的使用不再局限于自动内存管理，而是可以扩展到任何需要显式释放的资源。</p>
<h4 id="5-2-2-实现自定义删除器"><a href="#5-2-2-实现自定义删除器" class="headerlink" title="5.2.2 实现自定义删除器"></a>5.2.2 实现自定义删除器</h4><p>自定义删除器的实现可以根据具体的资源类型和清理需求进行设计。通常，删除器会是一个函数或者是一个函数对象，它接受一个参数——智能指针所管理的资源指针，并执行所有必要的清理工作。</p>
<p>例如，对于一个网络库中的连接对象，可能需要在释放前关闭连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;        <span class="comment">// 实现关闭连接的逻辑    &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closeConnection</span><span class="params">(Connection* conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;        conn-&gt;<span class="built_in">close</span>();    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Connection, <span class="title">decltype</span><span class="params">(&amp;closeConnection)</span>&gt; <span class="title">connPtr</span><span class="params">(<span class="keyword">new</span> Connection, &amp;closeConnection)</span></span>;    </span><br><span class="line">    <span class="comment">// 使用connPtr进行操作    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当connPtr离开作用域时，closeConnection会被自动调用来关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-自定义删除器的应用场景"><a href="#5-2-3-自定义删除器的应用场景" class="headerlink" title="5.2.3 自定义删除器的应用场景"></a>5.2.3 自定义删除器的应用场景</h4><p>自定义删除器尤其适用于那些需要复杂清理逻辑的场景，比如当对象的释放需要多步操作，或者依赖于特定的清理顺序时。它也适用于管理非内存资源，如文件句柄、数据库连接、或者网络连接等。</p>
<h4 id="5-2-4-自定义删除器与智能指针的互动"><a href="#5-2-4-自定义删除器与智能指针的互动" class="headerlink" title="5.2.4 自定义删除器与智能指针的互动"></a>5.2.4 自定义删除器与智能指针的互动</h4><p>使用自定义删除器时，开发者需要确保删除器的行为与智能指针的语义相匹配。例如，当使用<code>std::shared_ptr</code>时，删除器只会在最后一个<code>std::shared_ptr</code>对象被销毁时调用。这意味着，如果资源需要在所有引用它的智能指针之间共享，那么删除器需要能够正确处理这种共享行为。</p>
<h4 id="5-2-5-优化资源回收"><a href="#5-2-5-优化资源回收" class="headerlink" title="5.2.5 优化资源回收"></a>5.2.5 优化资源回收</h4><p>通过精心设计的自定义删除器，可以优化资源的回收过程，确保资源的释放既安全又高效。例如，通过延迟资源的释放到确实不再需要时，可以减少程序的内存占用和提高性能。同时，正确的资源管理还可以避免程序中出现难以追踪的资源泄露问题。</p>
<p>结合使用智能指针和自定义删除器，是现代C++中高效资源管理的关键技巧之一。它不仅提高了代码的可维护性和稳定性，而且还增强了程序对资源的控制能力，使得资源管理更加灵活和高效。</p>
<h3 id="5-3-智能指针与现代C-设计模式"><a href="#5-3-智能指针与现代C-设计模式" class="headerlink" title="5.3 智能指针与现代C++设计模式"></a>5.3 智能指针与现代C++设计模式</h3><p>在现代C++中，智能指针不仅是资源管理的基石，也是实现各种设计模式的关键工具。智能指针提供了一种安全且自动的方式来处理资源生命周期，这使得它们成为实现现代软件设计原则和模式的理想选择。在本节中，我们将探讨如何将智能指针与现代C++设计模式结合使用，以提升代码的质量和可维护性。</p>
<h4 id="5-3-1-工厂模式与智能指针"><a href="#5-3-1-工厂模式与智能指针" class="headerlink" title="5.3.1 工厂模式与智能指针"></a>5.3.1 工厂模式与智能指针</h4><p>工厂模式是一种创建对象的设计模式，它允许接口定义新对象的类型，但由子类决定实例化哪个类。在C++中，结合使用工厂模式和智能指针可以有效地管理对象的生命周期，同时避免内存泄漏。使用智能指针返回工厂方法创建的对象，可以确保即使发生异常，资源也能被正确释放。</p>
<p>例如，使用<code>std::unique_ptr</code>作为工厂方法的返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() = <span class="keyword">default</span>;    <span class="comment">// Product的其他接口</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="comment">// ConcreteProduct的实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProduct&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-观察者模式与智能指针"><a href="#5-3-2-观察者模式与智能指针" class="headerlink" title="5.3.2 观察者模式与智能指针"></a>5.3.2 观察者模式与智能指针</h4><p>观察者模式是一种对象间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会收到通知并自动更新。在C++中，<code>std::shared_ptr</code>和<code>std::weak_ptr</code>可以用来实现观察者模式，其中<code>std::weak_ptr</code>用于避免循环引用，保证观察者对象可以被适时地销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(std::shared_ptr&lt;Observer&gt; observer)</span> </span>&#123;        observers.<span class="built_in">push_back</span>(observer);    &#125;    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;        <span class="keyword">for</span> (<span class="keyword">auto</span> it = observers.<span class="built_in">begin</span>(); it != observers.<span class="built_in">end</span>(); ) &#123;            <span class="keyword">if</span> (<span class="keyword">auto</span> observer = it-&gt;<span class="built_in">lock</span>()) &#123;                observer-&gt;<span class="built_in">update</span>();                ++it;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果Observer已被销毁，则从列表中移除                it = observers.erase(it);            &#125;        &#125;    &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-单例模式与智能指针"><a href="#5-3-3-单例模式与智能指针" class="headerlink" title="5.3.3 单例模式与智能指针"></a>5.3.3 单例模式与智能指针</h4><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。在C++中，可以使用<code>std::shared_ptr</code>管理单例对象的实例，以利用智能指针的自动资源管理特性，保证单例实例在适当的时候被正确销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;Singleton&gt; instance;    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        <span class="keyword">if</span> (!instance) &#123;            instance = std::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);        &#125;        <span class="keyword">return</span> instance;    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-4-使用智能指针的优势"><a href="#5-3-4-使用智能指针的优势" class="headerlink" title="5.3.4 使用智能指针的优势"></a>5.3.4 使用智能指针的优势</h4><p>将智能指针与现代C++设计模式结合使用，可以带来多方面的好处：自动化的资源管理减少内存泄漏风险，代码更加简洁易读，同时提高了代码的可维护性和健壮性。智能指针的使用让设计模式的实现更加灵活，也使得资源管理更为安全和高效。</p>
<p>通过这种方式，开发者可以更加专注于业务逻辑的实现，而不必担心资源管理和内存泄漏等问题，从而提高开发效率和程序的稳定性。</p>
<h2 id="第六章-结语"><a href="#第六章-结语" class="headerlink" title="第六章: 结语"></a>第六章: 结语</h2><p>在本文的讨论中，我们深入探索了C++智能指针的内部机制、使用场景、以及避免滥用的策略。智能指针作为现代C++中管理动态分配内存的重要工具，其正确使用对于编写高效、可维护的代码至关重要。现在，让我们重申智能指针使用的一些核心原则，并总结如何避免常见的陷阱。</p>
<h3 id="6-1-重申智能指针使用的原则"><a href="#6-1-重申智能指针使用的原则" class="headerlink" title="6.1 重申智能指针使用的原则"></a>6.1 重申智能指针使用的原则</h3><p>智能指针的设计初衷是为了简化内存管理，减少内存泄漏的风险，同时提供类似于垃圾回收的自动化内存管理机制。然而，智能指针并非万能药，错误的使用方法不仅不能带来预期的好处，反而可能导致性能下降、资源泄漏或其他不可预见的问题。</p>
<ul>
<li><p><strong>选择合适的智能指针类型</strong>：根据具体需求选择<code>std::unique_ptr</code>、<code>std::shared_ptr</code>或<code>std::weak_ptr</code>。例如，当对象的所有权需要明确且唯一时，应优先选择<code>std::unique_ptr</code>。  </p>
</li>
<li><p><strong>避免不必要的智能指针使用</strong>：对于栈上的资源管理或非动态分配的资源，普通变量或容器往往是更好的选择。智能指针应主要用于动态分配的内存管理。  </p>
</li>
<li><p><strong>注意循环引用问题</strong>：特别是在使用<code>std::shared_ptr</code>时，要小心不要造成循环引用，因为这会导致内存泄漏。在这种情况下，使用<code>std::weak_ptr</code>来打破循环。  </p>
</li>
<li><p><strong>优先使用智能指针的工厂函数</strong>：如<code>std::make_unique</code>和<code>std::make_shared</code>，它们不仅可以减少代码量，提高代码清晰度，还可以提供比直接使用智能指针构造函数更好的性能。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ControlBlock</span>() : <span class="built_in">use_count_</span>(<span class="number">1</span>), <span class="built_in">weak_count_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">int</span>&gt; use_count_;   <span class="comment">// 引用计数</span></span><br><span class="line">  std::atomic&lt;<span class="type">int</span>&gt; weak_count_;  <span class="comment">// 弱引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SharedPtr</span>(T* p) : <span class="built_in">ptr</span>(p), <span class="built_in">control_block_</span>(<span class="keyword">new</span> <span class="built_in">ControlBlock</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造</span></span><br><span class="line">  <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&amp; other)</span><br><span class="line">      : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">control_block_</span>(other.control_block_) &#123;</span><br><span class="line">    ++control_block_-&gt;use_count_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造</span></span><br><span class="line">  <span class="built_in">SharedPtr</span>(SharedPtr&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    control_block_ = other.control_block_;</span><br><span class="line">    ptr = other.ptr;</span><br><span class="line">    other.control_block_ = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (control_block_ &amp;&amp; --control_block_-&gt;use_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> control_block_;</span><br><span class="line">      <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// private:</span></span><br><span class="line">  T* ptr;  <span class="comment">// 管理资源的指针</span></span><br><span class="line">  ControlBlock&lt;T&gt;* control_block_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1&#x27;s value is : &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp2 = sp1;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;sp2&#x27;s value is : &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;use_count1 : &quot;</span> &lt;&lt; sp2.control_block_-&gt;use_count_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count2 : &quot;</span> &lt;&lt; sp1.control_block_-&gt;use_count_ &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*p != <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p is deleted when use_count is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1469245"></a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b6ac02d406a0"></a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hj605635529/article/details/76984839"></a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">1.智能指针的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2.智能指针的分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.智能指针的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1内存管理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%92%8C%E5%BB%B6%E8%BF%9F%E9%94%80%E6%AF%81"><span class="toc-number">3.2.</span> <span class="toc-text">3.2引用计数和延迟销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.智能指针的不合理使用会出现什么问题？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.什么时候才应该使用智能指针？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%80%A7%E8%83%BD%E6%95%8F%E6%84%9F%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">3.2 性能敏感区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">引用计数的性能开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%94%80%E6%AF%81%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">延迟销毁的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%80%83%E9%87%8F"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">适用场景的考量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%BB%86%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">5.0.1.4.</span> <span class="toc-text">精细的资源管理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%BA%A6%E6%9D%9F%E7%9A%84%E8%80%83%E9%87%8F"><span class="toc-number">5.0.1.5.</span> <span class="toc-text">资源约束的考量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%80%A7%E8%A6%81%E6%B1%82"><span class="toc-number">5.0.1.6.</span> <span class="toc-text">实时性要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%BB%86%E6%8E%A7%E5%88%B6%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">5.0.1.7.</span> <span class="toc-text">精细控制的需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">5.0.1.8.</span> <span class="toc-text">替代方案</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%BB%A5%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">第四章: 智能指针滥用的具体案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.0.1.</span> <span class="toc-text">4.1 循环引用与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">4.1.1 问题示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">4.1.2 解决策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E9%87%8D%E8%A6%81%E6%8F%90%E7%A4%BA"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">4.1.3 重要提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%94%99%E8%AF%AF%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.2.</span> <span class="toc-text">4.2 错误的智能指针转换与类型安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.2.0.1.</span> <span class="toc-text">4.2.1 错误示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E9%81%BF%E5%85%8D%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.2.0.2.</span> <span class="toc-text">4.2.3 避免类型安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%87%E5%BA%A6%E5%B0%81%E8%A3%85%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%BB%A5%E7%94%A8"><span class="toc-number">6.0.3.</span> <span class="toc-text">4.3 过度封装与接口滥用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">6.0.3.0.1.</span> <span class="toc-text">4.3.1 问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.0.3.0.2.</span> <span class="toc-text">4.3.2 正确的设计原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="toc-number">6.0.3.0.3.</span> <span class="toc-text">4.3.3 实践中的平衡</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-number">7.</span> <span class="toc-text">第五章: 正确使用智能指针的高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%8B%E5%8A%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">5.1 手动资源管理与智能指针的结合使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E7%90%86%E8%A7%A3%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">5.1.1 理解资源管理的复杂性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">5.1.2 结合使用的策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">5.1.3 自定义删除器的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-%E7%BB%93%E5%90%88%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">5.1.4 结合手动管理与智能指针的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">7.0.2.</span> <span class="toc-text">5.2 使用自定义删除器优化资源回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">5.2.1 自定义删除器的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">5.2.2 实现自定义删除器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">5.2.3 自定义删除器的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%92%E5%8A%A8"><span class="toc-number">7.0.2.4.</span> <span class="toc-text">5.2.4 自定义删除器与智能指针的互动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">7.0.2.5.</span> <span class="toc-text">5.2.5 优化资源回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E7%8E%B0%E4%BB%A3C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.3.</span> <span class="toc-text">5.3 智能指针与现代C++设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.1.</span> <span class="toc-text">5.3.1 工厂模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.2.</span> <span class="toc-text">5.3.2 观察者模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.0.3.3.</span> <span class="toc-text">5.3.3 单例模式与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.0.3.4.</span> <span class="toc-text">5.3.4 使用智能指针的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E8%AF%AD"><span class="toc-number">7.1.</span> <span class="toc-text">第六章: 结语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%87%8D%E7%94%B3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.1.</span> <span class="toc-text">6.1 重申智能指针使用的原则</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&text=智能指针底层原理详解"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&is_video=false&description=智能指针底层原理详解"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=智能指针底层原理详解&body=Check out this article: http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&title=智能指针底层原理详解"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&name=智能指针底层原理详解&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://desmoscook.github.io/2024/04/02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&t=智能指针底层原理详解"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    desmoscook
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
